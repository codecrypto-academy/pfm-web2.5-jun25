// app/api/networks/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { DockerManager } from '@/lib/docker-manager';
import { ResourceManager } from '@/lib/resource-manager';

const dockerManager = new DockerManager();
const resourceManager = new ResourceManager(dockerManager);

// ‚ö° GET: Obtener todas las redes
export async function GET() {
  try {
    console.log('üìã [API] Obteniendo lista de redes...');
    
    const networks = await dockerManager.docker.listNetworks();
    
    // Filtrar y enriquecer solo las redes de Besu
    const besuNetworks = await Promise.all(
      networks
        .filter(network => 
          network.Labels?.['created-by'] === 'besu-manager' ||
          network.Name.includes('besu') ||
          network.Driver === 'bridge' && network.Name !== 'bridge' && network.Name !== 'host' && network.Name !== 'none'
        )
        .map(async (network) => {
          try {
            const networkInfo = await dockerManager.getNetworkInfo(network.Id);
            return networkInfo;
          } catch (error) {
            console.warn(`‚ö†Ô∏è Error obteniendo info de red ${network.Name}:`, error);
            // Devolver info b√°sica si falla la detallada
            return {
              id: network.Id,
              name: network.Name,
              config: {
                subnet: network.IPAM?.Config?.[0]?.Subnet,
                gateway: network.IPAM?.Config?.[0]?.Gateway
              },
              containers: []
            };
          }
        })
    );

    console.log(`‚úÖ [API] ${besuNetworks.length} redes encontradas`);

    return NextResponse.json({
      success: true,
      data: besuNetworks,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('‚ùå [API] Error obteniendo redes:', error);
    return NextResponse.json(
      { error: 'Error al obtener las redes', details: error.message },
      { status: 500 }
    );
  }
}

// ‚ö° POST: Crear nueva red con subred autom√°tica
export async function POST(request: NextRequest) {
  try {
    const { name } = await request.json();

    if (!name || !name.trim()) {
      return NextResponse.json(
        { error: 'El nombre de la red es requerido' },
        { status: 400 }
      );
    }

    console.log('üåê [API] Creando nueva red:', name);

    // ‚ö° PASO 1: Generar configuraci√≥n autom√°tica
    console.log('üéØ [API] Generando configuraci√≥n autom√°tica...');
    const networkConfig = await resourceManager.generateNetworkConfiguration(name.trim());
    
    console.log('‚úÖ [API] Configuraci√≥n generada:', networkConfig);

    // ‚ö° PASO 2: Crear la red con configuraci√≥n autom√°tica
    const networkId = await dockerManager.createNetwork({
      name: networkConfig.name,
      subnet: networkConfig.subnet,
      labels: {
        'created-by': 'besu-manager',
        'protocol': 'clique',
        'original-name': name.trim(),
        'created-at': new Date().toISOString()
      }
    });

    console.log('‚úÖ [API] Red creada exitosamente:', networkId);

    // ‚ö° PASO 3: Obtener informaci√≥n completa de la red creada
    const networkInfo = await dockerManager.getNetworkInfo(networkId);

    return NextResponse.json({
      success: true,
      data: {
        ...networkInfo,
        originalName: name.trim(),
        autoGenerated: {
          name: networkConfig.name,
          subnet: networkConfig.subnet
        }
      },
      message: `Red "${networkConfig.name}" creada exitosamente con subred ${networkConfig.subnet}`,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå [API] Error creando red:', error);
    
    // Proporcionar informaci√≥n m√°s √∫til sobre el error
    let errorMessage = error.message;
    let suggestions = [];
    
    if (error.message.includes('Pool overlaps')) {
      suggestions.push('La subred autom√°tica tuvo un conflicto. Reintenta la operaci√≥n.');
      suggestions.push('Si persiste, verifica que no hay redes manuales conflictivas.');
    }
    
    if (error.message.includes('already exists')) {
      suggestions.push('Ya existe una red con un nombre similar.');
      suggestions.push('Prueba con un nombre diferente.');
    }

    return NextResponse.json(
      { 
        error: 'Error al crear la red',
        details: errorMessage,
        suggestions,
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    );
  }
}

// ‚ö° DELETE: Eliminar red espec√≠fica
export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const networkId = searchParams.get('id');
    
    if (!networkId) {
      return NextResponse.json(
        { error: 'ID de red requerido (par√°metro ?id=)' },
        { status: 400 }
      );
    }

    console.log(`üóëÔ∏è [API] Eliminando red: ${networkId}`);

    // Obtener informaci√≥n antes de eliminar para el log
    let networkName = networkId;
    try {
      const networkInfo = await dockerManager.getNetworkInfo(networkId);
      networkName = networkInfo.name;
    } catch {
      // Si no se puede obtener el nombre, usar el ID
    }

    // Eliminar la red y todos sus contenedores
    await dockerManager.removeNetwork(networkId, true);
    
    console.log(`‚úÖ [API] Red ${networkName} eliminada exitosamente`);

    return NextResponse.json({
      success: true,
      message: `Red "${networkName}" eliminada exitosamente`,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('‚ùå [API] Error eliminando red:', error);
    return NextResponse.json(
      { error: 'Error al eliminar la red', details: error.message },
      { status: 500 }
    );
  }
}

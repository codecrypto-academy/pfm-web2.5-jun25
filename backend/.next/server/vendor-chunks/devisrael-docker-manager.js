"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/devisrael-docker-manager";
exports.ids = ["vendor-chunks/devisrael-docker-manager"];
exports.modules = {

/***/ "(rsc)/./node_modules/devisrael-docker-manager/dist/besu-deployer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/devisrael-docker-manager/dist/besu-deployer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function() {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function(o) {\n            var ar = [];\n            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function(mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) {\n            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BesuDeployer = void 0;\nconst docker_manager_1 = __webpack_require__(/*! ./docker-manager */ \"(rsc)/./node_modules/devisrael-docker-manager/dist/docker-manager.js\");\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst crypto = __importStar(__webpack_require__(/*! crypto */ \"crypto\"));\nclass BesuDeployer extends docker_manager_1.DockerManager {\n    constructor(networkConfig){\n        super();\n        this.networkConfig = networkConfig;\n    }\n    /**\n     * Despliega una red completa de Besu\n     */ async deployBesuNetwork(nodes) {\n        try {\n            // 1. Limpiar red existente PRIMERO\n            await this.cleanupNetwork();\n            // 2. Limpiar datos anteriores\n            await this.cleanupPreviousData();\n            // 3. Crear directorio si no existe\n            await this.ensureDataDirectory();\n            // 4. Crear directorios y llaves para cada nodo\n            await this.createNodeDirectories(nodes);\n            // 5. Actualizar configuración con enode del bootnode\n            await this.updateConfigWithBootnode(nodes);\n            // 6. Crear red Docker\n            await this.createBesuNetwork();\n            // 7. Desplegar nodos\n            for (const node of nodes){\n                await this.deployBesuNode(node);\n                // Esperar un poco entre despliegues\n                await this.sleep(2000);\n            }\n            console.log(`Red Besu desplegada con ${nodes.length} nodos`);\n        } catch (error) {\n            throw new Error(`Error desplegando red Besu: ${error.message}`);\n        }\n    }\n    /**\n     * Limpia datos anteriores de Besu\n     */ async cleanupPreviousData() {\n        const absolutePath = path.resolve(this.networkConfig.dataPath);\n        if (fs.existsSync(absolutePath)) {\n            console.log(\"Limpiando datos anteriores...\");\n            // Eliminar todo el directorio y recrearlo\n            this.removeDirectoryRecursive(absolutePath);\n            console.log(\"Datos anteriores eliminados\");\n        }\n    }\n    /**\n     * Elimina un directorio de forma recursiva\n     */ removeDirectoryRecursive(dirPath) {\n        if (fs.existsSync(dirPath)) {\n            fs.rmSync(dirPath, {\n                recursive: true,\n                force: true\n            });\n        }\n    }\n    /**\n     * Asegura que el directorio de datos existe\n     */ async ensureDataDirectory() {\n        const absolutePath = path.resolve(this.networkConfig.dataPath);\n        if (!fs.existsSync(absolutePath)) {\n            fs.mkdirSync(absolutePath, {\n                recursive: true\n            });\n            console.log(`Directorio creado: ${absolutePath}`);\n        }\n        // Crear archivos de configuración básicos\n        await this.createConfigFiles(absolutePath);\n    }\n    /**\n     * Crea archivos de configuración básicos para Besu\n     */ async createConfigFiles(dataPath) {\n        // Crear config.toml básico\n        const configContent = `genesis-file=\"/data/genesis.json\"\r\np2p-host=\"0.0.0.0\"\r\np2p-port=\"30303\"\r\np2p-enabled=true\r\ndiscovery-enabled=true\r\nrpc-http-enabled=true\r\nrpc-http-host=\"0.0.0.0\"\r\nrpc-http-port=8545\r\nrpc-http-cors-origins=[\"*\"]\r\nrpc-http-api=[\"ADMIN\",\"ETH\", \"CLIQUE\", \"NET\", \"TRACE\", \"DEBUG\", \"TXPOOL\", \"PERM\"]\r\nhost-allowlist=[\"*\"]`;\n        // Crear bootnode-config.toml\n        const bootnodeConfigContent = `genesis-file=\"/data/genesis.json\"\r\np2p-host=\"0.0.0.0\"\r\np2p-port=\"30303\"\r\np2p-enabled=true\r\ndiscovery-enabled=true\r\nrpc-http-enabled=true\r\nrpc-http-host=\"0.0.0.0\"\r\nrpc-http-port=8545\r\nrpc-http-cors-origins=[\"*\"]\r\nrpc-http-api=[\"ADMIN\",\"ETH\", \"CLIQUE\", \"NET\", \"TRACE\", \"DEBUG\", \"TXPOOL\", \"PERM\"]\r\nhost-allowlist=[\"*\"]`;\n        // Crear genesis.json básico\n        const genesisContent = {\n            config: {\n                chainId: 246700,\n                londonBlock: 0,\n                clique: {\n                    blockperiodseconds: 4,\n                    epochlenght: 30000,\n                    createemptyblocks: true\n                }\n            },\n            extraData: \"0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n            gasLimit: \"0x1fffffffffffff\",\n            difficulty: \"0x1\",\n            alloc: {}\n        };\n        // Escribir archivos\n        const configPath = path.join(dataPath, \"config.toml\");\n        const bootnodeConfigPath = path.join(dataPath, \"bootnode-config.toml\");\n        const genesisPath = path.join(dataPath, \"genesis.json\");\n        fs.writeFileSync(configPath, configContent);\n        fs.writeFileSync(bootnodeConfigPath, bootnodeConfigContent);\n        fs.writeFileSync(genesisPath, JSON.stringify(genesisContent, null, 2));\n        console.log(`Archivos creados:`);\n        console.log(`  - ${configPath}`);\n        console.log(`  - ${bootnodeConfigPath}`);\n        console.log(`  - ${genesisPath}`);\n    }\n    /**\n     * Crea directorios y archivos básicos para cada nodo\n     */ async createNodeDirectories(nodes) {\n        const basePath = path.resolve(this.networkConfig.dataPath);\n        for (const node of nodes){\n            const nodePath = path.join(basePath, node.name);\n            const dataPath = path.join(nodePath, \"data\");\n            // Crear directorios\n            fs.mkdirSync(nodePath, {\n                recursive: true\n            });\n            fs.mkdirSync(dataPath, {\n                recursive: true\n            });\n            // Generar llave privada real (32 bytes = 64 caracteres hex)\n            const privateKey = crypto.randomBytes(32);\n            const privateKeyHex = \"0x\" + privateKey.toString(\"hex\");\n            // Simular dirección (en producción usarías la derivada de la llave pública)\n            const addressBytes = crypto.randomBytes(20);\n            const address = addressBytes.toString(\"hex\");\n            // Escribir archivos - Besu necesita la llave sin salto de línea\n            fs.writeFileSync(path.join(nodePath, \"key\"), privateKeyHex, {\n                flag: \"w\"\n            });\n            fs.writeFileSync(path.join(nodePath, \"address\"), address, {\n                flag: \"w\"\n            });\n            // Si es bootnode, crear enode\n            if (node.isBootnode) {\n                // Para el enode necesitamos la clave pública (64 bytes = 128 caracteres hex)\n                const publicKeyBytes = crypto.randomBytes(64);\n                const publicKey = publicKeyBytes.toString(\"hex\");\n                const enode = `enode://${publicKey}@${node.ip}:30303`;\n                fs.writeFileSync(path.join(nodePath, \"enode\"), enode, {\n                    flag: \"w\"\n                });\n                console.log(`Enode creado para bootnode: ${enode}`);\n            }\n            console.log(`Directorio y llaves creados para ${node.name}`);\n            console.log(`  - Llave privada: ${privateKeyHex.substring(0, 18)}...`);\n            console.log(`  - Dirección: 0x${address}`);\n            // Verificar que el archivo de llave tiene el tamaño correcto\n            const keyContent = fs.readFileSync(path.join(nodePath, \"key\"), \"utf8\");\n            console.log(`  - Tamaño de llave: ${keyContent.length} caracteres`);\n        }\n    }\n    /**\n     * Actualiza la configuración con el enode del bootnode\n     */ async updateConfigWithBootnode(nodes) {\n        const basePath = path.resolve(this.networkConfig.dataPath);\n        const bootnode = nodes.find((node)=>node.isBootnode);\n        if (!bootnode) {\n            console.log(\"No se encontr\\xf3 bootnode, saltando configuraci\\xf3n de bootnodes\");\n            return;\n        }\n        // Leer el enode del bootnode\n        const enodePath = path.join(basePath, bootnode.name, \"enode\");\n        const enode = fs.readFileSync(enodePath, \"utf8\").trim();\n        // Actualizar config.toml con el bootnode\n        const configContent = `genesis-file=\"/data/genesis.json\"\r\np2p-host=\"0.0.0.0\"\r\np2p-port=\"30303\"\r\np2p-enabled=true\r\nbootnodes=[\"${enode}\"]\r\ndiscovery-enabled=true\r\nrpc-http-enabled=true\r\nrpc-http-host=\"0.0.0.0\"\r\nrpc-http-port=8545\r\nrpc-http-cors-origins=[\"*\"]\r\nrpc-http-api=[\"ADMIN\",\"ETH\", \"CLIQUE\", \"NET\", \"TRACE\", \"DEBUG\", \"TXPOOL\", \"PERM\"]\r\nhost-allowlist=[\"*\"]`;\n        const configPath = path.join(basePath, \"config.toml\");\n        fs.writeFileSync(configPath, configContent);\n        // Actualizar genesis.json con las direcciones de los validadores\n        await this.updateGenesisWithValidators(nodes);\n        console.log(`Configuración actualizada con bootnode: ${enode}`);\n    }\n    /**\n     * Actualiza el genesis.json con las direcciones de los validadores\n     */ async updateGenesisWithValidators(nodes) {\n        const basePath = path.resolve(this.networkConfig.dataPath);\n        // Obtener direcciones de nodos mineros/validadores\n        const minerNodes = nodes.filter((node)=>node.isMiner || node.isBootnode);\n        let extraData = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n        // Agregar direcciones de validadores al extraData\n        for (const node of minerNodes){\n            const addressPath = path.join(basePath, node.name, \"address\");\n            const address = fs.readFileSync(addressPath, \"utf8\").trim();\n            extraData += address;\n        }\n        // Agregar sufijo requerido para Clique\n        extraData += \"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n        // Crear balance inicial para el primer minero\n        const firstMinerAddress = fs.readFileSync(path.join(basePath, minerNodes[0].name, \"address\"), \"utf8\").trim();\n        const genesisContent = {\n            config: {\n                chainId: 246700,\n                londonBlock: 0,\n                clique: {\n                    blockperiodseconds: 4,\n                    epochlenght: 30000,\n                    createemptyblocks: true\n                }\n            },\n            extraData: extraData,\n            gasLimit: \"0x1fffffffffffff\",\n            difficulty: \"0x1\",\n            alloc: {\n                [`0x${firstMinerAddress}`]: {\n                    balance: \"0x20000000000000000000000000000000000000000000000000000000000\"\n                }\n            }\n        };\n        const genesisPath = path.join(basePath, \"genesis.json\");\n        fs.writeFileSync(genesisPath, JSON.stringify(genesisContent, null, 2));\n        console.log(`Genesis actualizado con ${minerNodes.length} validadores`);\n        console.log(`  - extraData: ${extraData.substring(0, 50)}...`);\n    }\n    /**\n     * Crea la red Docker para Besu\n     */ async createBesuNetwork() {\n        await this.createNetwork({\n            name: this.networkConfig.networkName,\n            subnet: this.networkConfig.subnet,\n            labels: {\n                \"network\": this.networkConfig.networkName,\n                \"type\": \"besu\"\n            }\n        });\n    }\n    /**\n     * Despliega un nodo Besu individual\n     */ async deployBesuNode(nodeConfig) {\n        const containerOptions = this.buildBesuContainerOptions(nodeConfig);\n        console.log(`\\n--- Desplegando ${nodeConfig.name} ---`);\n        console.log(`  IP: ${nodeConfig.ip}`);\n        console.log(`  Tipo: ${this.getNodeType(nodeConfig)}`);\n        try {\n            const containerId = await this.createContainer(containerOptions);\n            console.log(`  Container ID: ${containerId.substring(0, 12)}`);\n            // Esperar un poco más para que el contenedor se inicie\n            console.log(`  Esperando que ${nodeConfig.name} se inicie...`);\n            await this.sleep(3000);\n            // Verificar que el contenedor se inició correctamente\n            const containerInfo = await this.getContainerInfo(containerId);\n            console.log(`  Estado: ${containerInfo.state}`);\n            if (containerInfo.state !== \"running\") {\n                console.log(`  ⚠️  ${nodeConfig.name} no está corriendo!`);\n            } else {\n                console.log(`  ✅ ${nodeConfig.name} funcionando correctamente`);\n            }\n            return containerId;\n        } catch (error) {\n            console.error(`❌ Error desplegando ${nodeConfig.name}:`, error);\n            throw error;\n        }\n    }\n    /**\n     * Construye las opciones del contenedor para un nodo Besu\n     */ buildBesuContainerOptions(nodeConfig) {\n        // Convertir a ruta absoluta\n        const absolutePath = path.resolve(this.networkConfig.dataPath);\n        const volumeMount = `${absolutePath}:/data`;\n        const labels = {\n            \"network\": this.networkConfig.networkName,\n            \"node-type\": this.getNodeType(nodeConfig)\n        };\n        const cmd = this.buildBesuCommand(nodeConfig);\n        const portBindings = {};\n        // Si es nodo RPC, exponer puerto\n        if (nodeConfig.isRpc) {\n            portBindings[\"8545/tcp\"] = [\n                {\n                    HostPort: \"1002\"\n                }\n            ];\n        }\n        return {\n            name: nodeConfig.name,\n            Image: \"hyperledger/besu:latest\",\n            Cmd: cmd,\n            ExposedPorts: nodeConfig.isRpc ? {\n                \"8545/tcp\": {}\n            } : undefined,\n            HostConfig: {\n                Binds: [\n                    volumeMount\n                ],\n                PortBindings: Object.keys(portBindings).length > 0 ? portBindings : undefined\n            },\n            Labels: labels,\n            networkName: this.networkConfig.networkName,\n            ip: nodeConfig.ip\n        };\n    }\n    /**\n     * Construye el comando para ejecutar Besu\n     */ buildBesuCommand(nodeConfig) {\n        const configFile = nodeConfig.isBootnode ? \"/data/bootnode-config.toml\" : \"/data/config.toml\";\n        const cmd = [\n            `--config-file=${configFile}`,\n            `--data-path=/data/${nodeConfig.name}/data`,\n            `--node-private-key-file=/data/${nodeConfig.name}/key`\n        ];\n        if (nodeConfig.isMiner) {\n            cmd.push(\"--miner-enabled=true\");\n            cmd.push(`--miner-coinbase=0x$(cat /data/${nodeConfig.name}/address)`);\n        }\n        return cmd;\n    }\n    /**\n     * Limpia la red existente\n     */ async cleanupNetwork() {\n        try {\n            // Eliminar contenedores de la red\n            await this.removeNetwork(this.networkConfig.networkName, true);\n        } catch (error) {\n            // Si la red no existe, continuar\n            console.log(\"Red no existe o ya fue eliminada\");\n        }\n    }\n    /**\n     * Obtiene el tipo de nodo para labels\n     */ getNodeType(nodeConfig) {\n        if (nodeConfig.isBootnode) return \"bootnode\";\n        if (nodeConfig.isRpc) return \"rpc\";\n        if (nodeConfig.isMiner) return \"miner\";\n        return \"validator\";\n    }\n    /**\n     * Espera un tiempo determinado\n     */ sleep(ms) {\n        return new Promise((resolve)=>setTimeout(resolve, ms));\n    }\n    /**\n     * Obtiene información de todos los nodos de la red\n     */ async getNetworkStatus() {\n        try {\n            const networkInfo = await this.getNetworkInfo(this.networkConfig.networkName);\n            return {\n                network: {\n                    name: networkInfo.name,\n                    subnet: networkInfo.config.subnet,\n                    totalNodes: networkInfo.containers.length\n                },\n                nodes: networkInfo.containers.map((container)=>({\n                        name: container.name,\n                        ip: container.ip,\n                        id: container.id\n                    }))\n            };\n        } catch (error) {\n            throw new Error(`Error obteniendo estado de la red: ${error.message}`);\n        }\n    }\n    /**\n     * Obtiene los logs de un contenedor específico (útil para debugging)\n     */ async getNodeLogs(nodeName) {\n        try {\n            // Acceder al docker instance del padre\n            const dockerInstance = this.docker;\n            const container = dockerInstance.getContainer(nodeName);\n            const logs = await container.logs({\n                stdout: true,\n                stderr: true,\n                tail: 50\n            });\n            return logs.toString();\n        } catch (error) {\n            throw new Error(`Error obteniendo logs de ${nodeName}: ${error.message}`);\n        }\n    }\n}\nexports.BesuDeployer = BesuDeployer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZGV2aXNyYWVsLWRvY2tlci1tYW5hZ2VyL2Rpc3QvYmVzdS1kZXBsb3llci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxDQUFDLE1BQUcs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TUFBTSxDQUFDaUQsTUFBTTtvQkFDakNtQyxZQUFZSCxZQUFZSSxVQUFVLENBQUNqSSxNQUFNO2dCQUM3QztnQkFDQWUsT0FBTzhHLFlBQVlJLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDQyxDQUFBQSxZQUFjO3dCQUM1Q25FLE1BQU1tRSxVQUFVbkUsSUFBSTt3QkFDcEJZLElBQUl1RCxVQUFVdkQsRUFBRTt3QkFDaEJ3RCxJQUFJRCxVQUFVQyxFQUFFO29CQUNwQjtZQUNKO1FBQ0osRUFDQSxPQUFPekcsT0FBTztZQUNWLE1BQU0sSUFBSUMsTUFBTSxDQUFDLG1DQUFtQyxFQUFFRCxNQUFNRSxPQUFPLENBQUMsQ0FBQztRQUN6RTtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxNQUFNd0csWUFBWUMsUUFBUSxFQUFFO1FBQ3hCLElBQUk7WUFDQSx1Q0FBdUM7WUFDdkMsTUFBTUMsaUJBQWlCLElBQUksQ0FBQ0MsTUFBTTtZQUNsQyxNQUFNTCxZQUFZSSxlQUFlRSxZQUFZLENBQUNIO1lBQzlDLE1BQU1JLE9BQU8sTUFBTVAsVUFBVU8sSUFBSSxDQUFDO2dCQUM5QkMsUUFBUTtnQkFDUkMsUUFBUTtnQkFDUkMsTUFBTTtZQUNWO1lBQ0EsT0FBT0gsS0FBS3RFLFFBQVE7UUFDeEIsRUFDQSxPQUFPekMsT0FBTztZQUNWLE1BQU0sSUFBSUMsTUFBTSxDQUFDLHlCQUF5QixFQUFFMEcsU0FBUyxFQUFFLEVBQUUzRyxNQUFNRSxPQUFPLENBQUMsQ0FBQztRQUM1RTtJQUNKO0FBQ0o7QUFDQXpCLG9CQUFvQixHQUFHQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Jlc3UtbmV0d29yay1hcGkvLi9ub2RlX21vZHVsZXMvZGV2aXNyYWVsLWRvY2tlci1tYW5hZ2VyL2Rpc3QvYmVzdS1kZXBsb3llci5qcz84NDI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlc3VEZXBsb3llciA9IHZvaWQgMDtcbmNvbnN0IGRvY2tlcl9tYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9kb2NrZXItbWFuYWdlclwiKTtcbmNvbnN0IHBhdGggPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInBhdGhcIikpO1xuY29uc3QgZnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImZzXCIpKTtcbmNvbnN0IGNyeXB0byA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbmNsYXNzIEJlc3VEZXBsb3llciBleHRlbmRzIGRvY2tlcl9tYW5hZ2VyXzEuRG9ja2VyTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IobmV0d29ya0NvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5ldHdvcmtDb25maWcgPSBuZXR3b3JrQ29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXNwbGllZ2EgdW5hIHJlZCBjb21wbGV0YSBkZSBCZXN1XG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95QmVzdU5ldHdvcmsobm9kZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIDEuIExpbXBpYXIgcmVkIGV4aXN0ZW50ZSBQUklNRVJPXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsZWFudXBOZXR3b3JrKCk7XG4gICAgICAgICAgICAvLyAyLiBMaW1waWFyIGRhdG9zIGFudGVyaW9yZXNcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xlYW51cFByZXZpb3VzRGF0YSgpO1xuICAgICAgICAgICAgLy8gMy4gQ3JlYXIgZGlyZWN0b3JpbyBzaSBubyBleGlzdGVcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRGF0YURpcmVjdG9yeSgpO1xuICAgICAgICAgICAgLy8gNC4gQ3JlYXIgZGlyZWN0b3Jpb3MgeSBsbGF2ZXMgcGFyYSBjYWRhIG5vZG9cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlTm9kZURpcmVjdG9yaWVzKG5vZGVzKTtcbiAgICAgICAgICAgIC8vIDUuIEFjdHVhbGl6YXIgY29uZmlndXJhY2nDs24gY29uIGVub2RlIGRlbCBib290bm9kZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVDb25maWdXaXRoQm9vdG5vZGUobm9kZXMpO1xuICAgICAgICAgICAgLy8gNi4gQ3JlYXIgcmVkIERvY2tlclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVCZXN1TmV0d29yaygpO1xuICAgICAgICAgICAgLy8gNy4gRGVzcGxlZ2FyIG5vZG9zXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRlcGxveUJlc3VOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIEVzcGVyYXIgdW4gcG9jbyBlbnRyZSBkZXNwbGllZ3Vlc1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2xlZXAoMjAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVkIEJlc3UgZGVzcGxlZ2FkYSBjb24gJHtub2Rlcy5sZW5ndGh9IG5vZG9zYCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlc3BsZWdhbmRvIHJlZCBCZXN1OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGltcGlhIGRhdG9zIGFudGVyaW9yZXMgZGUgQmVzdVxuICAgICAqL1xuICAgIGFzeW5jIGNsZWFudXBQcmV2aW91c0RhdGEoKSB7XG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLm5ldHdvcmtDb25maWcuZGF0YVBhdGgpO1xuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhhYnNvbHV0ZVBhdGgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTGltcGlhbmRvIGRhdG9zIGFudGVyaW9yZXMuLi4nKTtcbiAgICAgICAgICAgIC8vIEVsaW1pbmFyIHRvZG8gZWwgZGlyZWN0b3JpbyB5IHJlY3JlYXJsb1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVEaXJlY3RvcnlSZWN1cnNpdmUoYWJzb2x1dGVQYXRoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEYXRvcyBhbnRlcmlvcmVzIGVsaW1pbmFkb3MnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbGltaW5hIHVuIGRpcmVjdG9yaW8gZGUgZm9ybWEgcmVjdXJzaXZhXG4gICAgICovXG4gICAgcmVtb3ZlRGlyZWN0b3J5UmVjdXJzaXZlKGRpclBhdGgpIHtcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZGlyUGF0aCkpIHtcbiAgICAgICAgICAgIGZzLnJtU3luYyhkaXJQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNlZ3VyYSBxdWUgZWwgZGlyZWN0b3JpbyBkZSBkYXRvcyBleGlzdGVcbiAgICAgKi9cbiAgICBhc3luYyBlbnN1cmVEYXRhRGlyZWN0b3J5KCkge1xuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5uZXR3b3JrQ29uZmlnLmRhdGFQYXRoKTtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGFic29sdXRlUGF0aCkpIHtcbiAgICAgICAgICAgIGZzLm1rZGlyU3luYyhhYnNvbHV0ZVBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYERpcmVjdG9yaW8gY3JlYWRvOiAke2Fic29sdXRlUGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhciBhcmNoaXZvcyBkZSBjb25maWd1cmFjacOzbiBiw6FzaWNvc1xuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUNvbmZpZ0ZpbGVzKGFic29sdXRlUGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWEgYXJjaGl2b3MgZGUgY29uZmlndXJhY2nDs24gYsOhc2ljb3MgcGFyYSBCZXN1XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQ29uZmlnRmlsZXMoZGF0YVBhdGgpIHtcbiAgICAgICAgLy8gQ3JlYXIgY29uZmlnLnRvbWwgYsOhc2ljb1xuICAgICAgICBjb25zdCBjb25maWdDb250ZW50ID0gYGdlbmVzaXMtZmlsZT1cIi9kYXRhL2dlbmVzaXMuanNvblwiXHJcbnAycC1ob3N0PVwiMC4wLjAuMFwiXHJcbnAycC1wb3J0PVwiMzAzMDNcIlxyXG5wMnAtZW5hYmxlZD10cnVlXHJcbmRpc2NvdmVyeS1lbmFibGVkPXRydWVcclxucnBjLWh0dHAtZW5hYmxlZD10cnVlXHJcbnJwYy1odHRwLWhvc3Q9XCIwLjAuMC4wXCJcclxucnBjLWh0dHAtcG9ydD04NTQ1XHJcbnJwYy1odHRwLWNvcnMtb3JpZ2lucz1bXCIqXCJdXHJcbnJwYy1odHRwLWFwaT1bXCJBRE1JTlwiLFwiRVRIXCIsIFwiQ0xJUVVFXCIsIFwiTkVUXCIsIFwiVFJBQ0VcIiwgXCJERUJVR1wiLCBcIlRYUE9PTFwiLCBcIlBFUk1cIl1cclxuaG9zdC1hbGxvd2xpc3Q9W1wiKlwiXWA7XG4gICAgICAgIC8vIENyZWFyIGJvb3Rub2RlLWNvbmZpZy50b21sXG4gICAgICAgIGNvbnN0IGJvb3Rub2RlQ29uZmlnQ29udGVudCA9IGBnZW5lc2lzLWZpbGU9XCIvZGF0YS9nZW5lc2lzLmpzb25cIlxyXG5wMnAtaG9zdD1cIjAuMC4wLjBcIlxyXG5wMnAtcG9ydD1cIjMwMzAzXCJcclxucDJwLWVuYWJsZWQ9dHJ1ZVxyXG5kaXNjb3ZlcnktZW5hYmxlZD10cnVlXHJcbnJwYy1odHRwLWVuYWJsZWQ9dHJ1ZVxyXG5ycGMtaHR0cC1ob3N0PVwiMC4wLjAuMFwiXHJcbnJwYy1odHRwLXBvcnQ9ODU0NVxyXG5ycGMtaHR0cC1jb3JzLW9yaWdpbnM9W1wiKlwiXVxyXG5ycGMtaHR0cC1hcGk9W1wiQURNSU5cIixcIkVUSFwiLCBcIkNMSVFVRVwiLCBcIk5FVFwiLCBcIlRSQUNFXCIsIFwiREVCVUdcIiwgXCJUWFBPT0xcIiwgXCJQRVJNXCJdXHJcbmhvc3QtYWxsb3dsaXN0PVtcIipcIl1gO1xuICAgICAgICAvLyBDcmVhciBnZW5lc2lzLmpzb24gYsOhc2ljb1xuICAgICAgICBjb25zdCBnZW5lc2lzQ29udGVudCA9IHtcbiAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgIGNoYWluSWQ6IDI0NjcwMCxcbiAgICAgICAgICAgICAgICBsb25kb25CbG9jazogMCxcbiAgICAgICAgICAgICAgICBjbGlxdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2twZXJpb2RzZWNvbmRzOiA0LFxuICAgICAgICAgICAgICAgICAgICBlcG9jaGxlbmdodDogMzAwMDAsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWVtcHR5YmxvY2tzOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4dHJhRGF0YTogXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgICAgIGdhc0xpbWl0OiBcIjB4MWZmZmZmZmZmZmZmZmZcIixcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IFwiMHgxXCIsXG4gICAgICAgICAgICBhbGxvYzoge31cbiAgICAgICAgfTtcbiAgICAgICAgLy8gRXNjcmliaXIgYXJjaGl2b3NcbiAgICAgICAgY29uc3QgY29uZmlnUGF0aCA9IHBhdGguam9pbihkYXRhUGF0aCwgJ2NvbmZpZy50b21sJyk7XG4gICAgICAgIGNvbnN0IGJvb3Rub2RlQ29uZmlnUGF0aCA9IHBhdGguam9pbihkYXRhUGF0aCwgJ2Jvb3Rub2RlLWNvbmZpZy50b21sJyk7XG4gICAgICAgIGNvbnN0IGdlbmVzaXNQYXRoID0gcGF0aC5qb2luKGRhdGFQYXRoLCAnZ2VuZXNpcy5qc29uJyk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoY29uZmlnUGF0aCwgY29uZmlnQ29udGVudCk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoYm9vdG5vZGVDb25maWdQYXRoLCBib290bm9kZUNvbmZpZ0NvbnRlbnQpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGdlbmVzaXNQYXRoLCBKU09OLnN0cmluZ2lmeShnZW5lc2lzQ29udGVudCwgbnVsbCwgMikpO1xuICAgICAgICBjb25zb2xlLmxvZyhgQXJjaGl2b3MgY3JlYWRvczpgKTtcbiAgICAgICAgY29uc29sZS5sb2coYCAgLSAke2NvbmZpZ1BhdGh9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgIC0gJHtib290bm9kZUNvbmZpZ1BhdGh9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgIC0gJHtnZW5lc2lzUGF0aH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYSBkaXJlY3RvcmlvcyB5IGFyY2hpdm9zIGLDoXNpY29zIHBhcmEgY2FkYSBub2RvXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlTm9kZURpcmVjdG9yaWVzKG5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGJhc2VQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMubmV0d29ya0NvbmZpZy5kYXRhUGF0aCk7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZVBhdGggPSBwYXRoLmpvaW4oYmFzZVBhdGgsIG5vZGUubmFtZSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhUGF0aCA9IHBhdGguam9pbihub2RlUGF0aCwgJ2RhdGEnKTtcbiAgICAgICAgICAgIC8vIENyZWFyIGRpcmVjdG9yaW9zXG4gICAgICAgICAgICBmcy5ta2RpclN5bmMobm9kZVBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgZnMubWtkaXJTeW5jKGRhdGFQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXIgbGxhdmUgcHJpdmFkYSByZWFsICgzMiBieXRlcyA9IDY0IGNhcmFjdGVyZXMgaGV4KVxuICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGNyeXB0by5yYW5kb21CeXRlcygzMik7XG4gICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5SGV4ID0gJzB4JyArIHByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgLy8gU2ltdWxhciBkaXJlY2Npw7NuIChlbiBwcm9kdWNjacOzbiB1c2Fyw61hcyBsYSBkZXJpdmFkYSBkZSBsYSBsbGF2ZSBww7pibGljYSlcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NCeXRlcyA9IGNyeXB0by5yYW5kb21CeXRlcygyMCk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYWRkcmVzc0J5dGVzLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgIC8vIEVzY3JpYmlyIGFyY2hpdm9zIC0gQmVzdSBuZWNlc2l0YSBsYSBsbGF2ZSBzaW4gc2FsdG8gZGUgbMOtbmVhXG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihub2RlUGF0aCwgJ2tleScpLCBwcml2YXRlS2V5SGV4LCB7IGZsYWc6ICd3JyB9KTtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKG5vZGVQYXRoLCAnYWRkcmVzcycpLCBhZGRyZXNzLCB7IGZsYWc6ICd3JyB9KTtcbiAgICAgICAgICAgIC8vIFNpIGVzIGJvb3Rub2RlLCBjcmVhciBlbm9kZVxuICAgICAgICAgICAgaWYgKG5vZGUuaXNCb290bm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIFBhcmEgZWwgZW5vZGUgbmVjZXNpdGFtb3MgbGEgY2xhdmUgcMO6YmxpY2EgKDY0IGJ5dGVzID0gMTI4IGNhcmFjdGVyZXMgaGV4KVxuICAgICAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDY0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBwdWJsaWNLZXlCeXRlcy50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5vZGUgPSBgZW5vZGU6Ly8ke3B1YmxpY0tleX1AJHtub2RlLmlwfTozMDMwM2A7XG4gICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4obm9kZVBhdGgsICdlbm9kZScpLCBlbm9kZSwgeyBmbGFnOiAndycgfSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVub2RlIGNyZWFkbyBwYXJhIGJvb3Rub2RlOiAke2Vub2RlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coYERpcmVjdG9yaW8geSBsbGF2ZXMgY3JlYWRvcyBwYXJhICR7bm9kZS5uYW1lfWApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgLSBMbGF2ZSBwcml2YWRhOiAke3ByaXZhdGVLZXlIZXguc3Vic3RyaW5nKDAsIDE4KX0uLi5gKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgIC0gRGlyZWNjacOzbjogMHgke2FkZHJlc3N9YCk7XG4gICAgICAgICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIGFyY2hpdm8gZGUgbGxhdmUgdGllbmUgZWwgdGFtYcOxbyBjb3JyZWN0b1xuICAgICAgICAgICAgY29uc3Qga2V5Q29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4obm9kZVBhdGgsICdrZXknKSwgJ3V0ZjgnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgIC0gVGFtYcOxbyBkZSBsbGF2ZTogJHtrZXlDb250ZW50Lmxlbmd0aH0gY2FyYWN0ZXJlc2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdHVhbGl6YSBsYSBjb25maWd1cmFjacOzbiBjb24gZWwgZW5vZGUgZGVsIGJvb3Rub2RlXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQ29uZmlnV2l0aEJvb3Rub2RlKG5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGJhc2VQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMubmV0d29ya0NvbmZpZy5kYXRhUGF0aCk7XG4gICAgICAgIGNvbnN0IGJvb3Rub2RlID0gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaXNCb290bm9kZSk7XG4gICAgICAgIGlmICghYm9vdG5vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdObyBzZSBlbmNvbnRyw7MgYm9vdG5vZGUsIHNhbHRhbmRvIGNvbmZpZ3VyYWNpw7NuIGRlIGJvb3Rub2RlcycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIExlZXIgZWwgZW5vZGUgZGVsIGJvb3Rub2RlXG4gICAgICAgIGNvbnN0IGVub2RlUGF0aCA9IHBhdGguam9pbihiYXNlUGF0aCwgYm9vdG5vZGUubmFtZSwgJ2Vub2RlJyk7XG4gICAgICAgIGNvbnN0IGVub2RlID0gZnMucmVhZEZpbGVTeW5jKGVub2RlUGF0aCwgJ3V0ZjgnKS50cmltKCk7XG4gICAgICAgIC8vIEFjdHVhbGl6YXIgY29uZmlnLnRvbWwgY29uIGVsIGJvb3Rub2RlXG4gICAgICAgIGNvbnN0IGNvbmZpZ0NvbnRlbnQgPSBgZ2VuZXNpcy1maWxlPVwiL2RhdGEvZ2VuZXNpcy5qc29uXCJcclxucDJwLWhvc3Q9XCIwLjAuMC4wXCJcclxucDJwLXBvcnQ9XCIzMDMwM1wiXHJcbnAycC1lbmFibGVkPXRydWVcclxuYm9vdG5vZGVzPVtcIiR7ZW5vZGV9XCJdXHJcbmRpc2NvdmVyeS1lbmFibGVkPXRydWVcclxucnBjLWh0dHAtZW5hYmxlZD10cnVlXHJcbnJwYy1odHRwLWhvc3Q9XCIwLjAuMC4wXCJcclxucnBjLWh0dHAtcG9ydD04NTQ1XHJcbnJwYy1odHRwLWNvcnMtb3JpZ2lucz1bXCIqXCJdXHJcbnJwYy1odHRwLWFwaT1bXCJBRE1JTlwiLFwiRVRIXCIsIFwiQ0xJUVVFXCIsIFwiTkVUXCIsIFwiVFJBQ0VcIiwgXCJERUJVR1wiLCBcIlRYUE9PTFwiLCBcIlBFUk1cIl1cclxuaG9zdC1hbGxvd2xpc3Q9W1wiKlwiXWA7XG4gICAgICAgIGNvbnN0IGNvbmZpZ1BhdGggPSBwYXRoLmpvaW4oYmFzZVBhdGgsICdjb25maWcudG9tbCcpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGNvbmZpZ1BhdGgsIGNvbmZpZ0NvbnRlbnQpO1xuICAgICAgICAvLyBBY3R1YWxpemFyIGdlbmVzaXMuanNvbiBjb24gbGFzIGRpcmVjY2lvbmVzIGRlIGxvcyB2YWxpZGFkb3Jlc1xuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZUdlbmVzaXNXaXRoVmFsaWRhdG9ycyhub2Rlcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDb25maWd1cmFjacOzbiBhY3R1YWxpemFkYSBjb24gYm9vdG5vZGU6ICR7ZW5vZGV9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdHVhbGl6YSBlbCBnZW5lc2lzLmpzb24gY29uIGxhcyBkaXJlY2Npb25lcyBkZSBsb3MgdmFsaWRhZG9yZXNcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVHZW5lc2lzV2l0aFZhbGlkYXRvcnMobm9kZXMpIHtcbiAgICAgICAgY29uc3QgYmFzZVBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5uZXR3b3JrQ29uZmlnLmRhdGFQYXRoKTtcbiAgICAgICAgLy8gT2J0ZW5lciBkaXJlY2Npb25lcyBkZSBub2RvcyBtaW5lcm9zL3ZhbGlkYWRvcmVzXG4gICAgICAgIGNvbnN0IG1pbmVyTm9kZXMgPSBub2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLmlzTWluZXIgfHwgbm9kZS5pc0Jvb3Rub2RlKTtcbiAgICAgICAgbGV0IGV4dHJhRGF0YSA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgICAgIC8vIEFncmVnYXIgZGlyZWNjaW9uZXMgZGUgdmFsaWRhZG9yZXMgYWwgZXh0cmFEYXRhXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBtaW5lck5vZGVzKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzUGF0aCA9IHBhdGguam9pbihiYXNlUGF0aCwgbm9kZS5uYW1lLCAnYWRkcmVzcycpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGZzLnJlYWRGaWxlU3luYyhhZGRyZXNzUGF0aCwgJ3V0ZjgnKS50cmltKCk7XG4gICAgICAgICAgICBleHRyYURhdGEgKz0gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICAvLyBBZ3JlZ2FyIHN1ZmlqbyByZXF1ZXJpZG8gcGFyYSBDbGlxdWVcbiAgICAgICAgZXh0cmFEYXRhICs9IFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgICAgICAvLyBDcmVhciBiYWxhbmNlIGluaWNpYWwgcGFyYSBlbCBwcmltZXIgbWluZXJvXG4gICAgICAgIGNvbnN0IGZpcnN0TWluZXJBZGRyZXNzID0gZnMucmVhZEZpbGVTeW5jKHBhdGguam9pbihiYXNlUGF0aCwgbWluZXJOb2Rlc1swXS5uYW1lLCAnYWRkcmVzcycpLCAndXRmOCcpLnRyaW0oKTtcbiAgICAgICAgY29uc3QgZ2VuZXNpc0NvbnRlbnQgPSB7XG4gICAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICAgICBjaGFpbklkOiAyNDY3MDAsXG4gICAgICAgICAgICAgICAgbG9uZG9uQmxvY2s6IDAsXG4gICAgICAgICAgICAgICAgY2xpcXVlOiB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrcGVyaW9kc2Vjb25kczogNCxcbiAgICAgICAgICAgICAgICAgICAgZXBvY2hsZW5naHQ6IDMwMDAwLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVlbXB0eWJsb2NrczogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHRyYURhdGE6IGV4dHJhRGF0YSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBcIjB4MWZmZmZmZmZmZmZmZmZcIixcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IFwiMHgxXCIsXG4gICAgICAgICAgICBhbGxvYzoge1xuICAgICAgICAgICAgICAgIFtgMHgke2ZpcnN0TWluZXJBZGRyZXNzfWBdOiB7XG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2U6IFwiMHgyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZW5lc2lzUGF0aCA9IHBhdGguam9pbihiYXNlUGF0aCwgJ2dlbmVzaXMuanNvbicpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGdlbmVzaXNQYXRoLCBKU09OLnN0cmluZ2lmeShnZW5lc2lzQ29udGVudCwgbnVsbCwgMikpO1xuICAgICAgICBjb25zb2xlLmxvZyhgR2VuZXNpcyBhY3R1YWxpemFkbyBjb24gJHttaW5lck5vZGVzLmxlbmd0aH0gdmFsaWRhZG9yZXNgKTtcbiAgICAgICAgY29uc29sZS5sb2coYCAgLSBleHRyYURhdGE6ICR7ZXh0cmFEYXRhLnN1YnN0cmluZygwLCA1MCl9Li4uYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWEgbGEgcmVkIERvY2tlciBwYXJhIEJlc3VcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVCZXN1TmV0d29yaygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVOZXR3b3JrKHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmV0d29ya0NvbmZpZy5uZXR3b3JrTmFtZSxcbiAgICAgICAgICAgIHN1Ym5ldDogdGhpcy5uZXR3b3JrQ29uZmlnLnN1Ym5ldCxcbiAgICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgICAgICduZXR3b3JrJzogdGhpcy5uZXR3b3JrQ29uZmlnLm5ldHdvcmtOYW1lLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jlc3UnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXNwbGllZ2EgdW4gbm9kbyBCZXN1IGluZGl2aWR1YWxcbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lCZXN1Tm9kZShub2RlQ29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lck9wdGlvbnMgPSB0aGlzLmJ1aWxkQmVzdUNvbnRhaW5lck9wdGlvbnMobm9kZUNvbmZpZyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBcXG4tLS0gRGVzcGxlZ2FuZG8gJHtub2RlQ29uZmlnLm5hbWV9IC0tLWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICBJUDogJHtub2RlQ29uZmlnLmlwfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICBUaXBvOiAke3RoaXMuZ2V0Tm9kZVR5cGUobm9kZUNvbmZpZyl9YCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJJZCA9IGF3YWl0IHRoaXMuY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgQ29udGFpbmVyIElEOiAke2NvbnRhaW5lcklkLnN1YnN0cmluZygwLCAxMil9YCk7XG4gICAgICAgICAgICAvLyBFc3BlcmFyIHVuIHBvY28gbcOhcyBwYXJhIHF1ZSBlbCBjb250ZW5lZG9yIHNlIGluaWNpZVxuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgRXNwZXJhbmRvIHF1ZSAke25vZGVDb25maWcubmFtZX0gc2UgaW5pY2llLi4uYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNsZWVwKDMwMDApO1xuICAgICAgICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCBjb250ZW5lZG9yIHNlIGluaWNpw7MgY29ycmVjdGFtZW50ZVxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVySW5mbyA9IGF3YWl0IHRoaXMuZ2V0Q29udGFpbmVySW5mbyhjb250YWluZXJJZCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICBFc3RhZG86ICR7Y29udGFpbmVySW5mby5zdGF0ZX1gKTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXJJbmZvLnN0YXRlICE9PSAncnVubmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICDimqDvuI8gICR7bm9kZUNvbmZpZy5uYW1lfSBubyBlc3TDoSBjb3JyaWVuZG8hYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICDinIUgJHtub2RlQ29uZmlnLm5hbWV9IGZ1bmNpb25hbmRvIGNvcnJlY3RhbWVudGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBkZXNwbGVnYW5kbyAke25vZGVDb25maWcubmFtZX06YCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydXllIGxhcyBvcGNpb25lcyBkZWwgY29udGVuZWRvciBwYXJhIHVuIG5vZG8gQmVzdVxuICAgICAqL1xuICAgIGJ1aWxkQmVzdUNvbnRhaW5lck9wdGlvbnMobm9kZUNvbmZpZykge1xuICAgICAgICAvLyBDb252ZXJ0aXIgYSBydXRhIGFic29sdXRhXG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLm5ldHdvcmtDb25maWcuZGF0YVBhdGgpO1xuICAgICAgICBjb25zdCB2b2x1bWVNb3VudCA9IGAke2Fic29sdXRlUGF0aH06L2RhdGFgO1xuICAgICAgICBjb25zdCBsYWJlbHMgPSB7XG4gICAgICAgICAgICAnbmV0d29yayc6IHRoaXMubmV0d29ya0NvbmZpZy5uZXR3b3JrTmFtZSxcbiAgICAgICAgICAgICdub2RlLXR5cGUnOiB0aGlzLmdldE5vZGVUeXBlKG5vZGVDb25maWcpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNtZCA9IHRoaXMuYnVpbGRCZXN1Q29tbWFuZChub2RlQ29uZmlnKTtcbiAgICAgICAgY29uc3QgcG9ydEJpbmRpbmdzID0ge307XG4gICAgICAgIC8vIFNpIGVzIG5vZG8gUlBDLCBleHBvbmVyIHB1ZXJ0b1xuICAgICAgICBpZiAobm9kZUNvbmZpZy5pc1JwYykge1xuICAgICAgICAgICAgcG9ydEJpbmRpbmdzWyc4NTQ1L3RjcCddID0gW3sgSG9zdFBvcnQ6ICcxMDAyJyB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogbm9kZUNvbmZpZy5uYW1lLFxuICAgICAgICAgICAgSW1hZ2U6ICdoeXBlcmxlZGdlci9iZXN1OmxhdGVzdCcsXG4gICAgICAgICAgICBDbWQ6IGNtZCxcbiAgICAgICAgICAgIEV4cG9zZWRQb3J0czogbm9kZUNvbmZpZy5pc1JwYyA/IHsgJzg1NDUvdGNwJzoge30gfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIEhvc3RDb25maWc6IHtcbiAgICAgICAgICAgICAgICBCaW5kczogW3ZvbHVtZU1vdW50XSxcbiAgICAgICAgICAgICAgICBQb3J0QmluZGluZ3M6IE9iamVjdC5rZXlzKHBvcnRCaW5kaW5ncykubGVuZ3RoID4gMCA/IHBvcnRCaW5kaW5ncyA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIExhYmVsczogbGFiZWxzLFxuICAgICAgICAgICAgbmV0d29ya05hbWU6IHRoaXMubmV0d29ya0NvbmZpZy5uZXR3b3JrTmFtZSxcbiAgICAgICAgICAgIGlwOiBub2RlQ29uZmlnLmlwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnV5ZSBlbCBjb21hbmRvIHBhcmEgZWplY3V0YXIgQmVzdVxuICAgICAqL1xuICAgIGJ1aWxkQmVzdUNvbW1hbmQobm9kZUNvbmZpZykge1xuICAgICAgICBjb25zdCBjb25maWdGaWxlID0gbm9kZUNvbmZpZy5pc0Jvb3Rub2RlID9cbiAgICAgICAgICAgICcvZGF0YS9ib290bm9kZS1jb25maWcudG9tbCcgOlxuICAgICAgICAgICAgJy9kYXRhL2NvbmZpZy50b21sJztcbiAgICAgICAgY29uc3QgY21kID0gW1xuICAgICAgICAgICAgYC0tY29uZmlnLWZpbGU9JHtjb25maWdGaWxlfWAsXG4gICAgICAgICAgICBgLS1kYXRhLXBhdGg9L2RhdGEvJHtub2RlQ29uZmlnLm5hbWV9L2RhdGFgLFxuICAgICAgICAgICAgYC0tbm9kZS1wcml2YXRlLWtleS1maWxlPS9kYXRhLyR7bm9kZUNvbmZpZy5uYW1lfS9rZXlgXG4gICAgICAgIF07XG4gICAgICAgIGlmIChub2RlQ29uZmlnLmlzTWluZXIpIHtcbiAgICAgICAgICAgIGNtZC5wdXNoKCctLW1pbmVyLWVuYWJsZWQ9dHJ1ZScpO1xuICAgICAgICAgICAgY21kLnB1c2goYC0tbWluZXItY29pbmJhc2U9MHgkKGNhdCAvZGF0YS8ke25vZGVDb25maWcubmFtZX0vYWRkcmVzcylgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY21kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaW1waWEgbGEgcmVkIGV4aXN0ZW50ZVxuICAgICAqL1xuICAgIGFzeW5jIGNsZWFudXBOZXR3b3JrKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRWxpbWluYXIgY29udGVuZWRvcmVzIGRlIGxhIHJlZFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW1vdmVOZXR3b3JrKHRoaXMubmV0d29ya0NvbmZpZy5uZXR3b3JrTmFtZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBTaSBsYSByZWQgbm8gZXhpc3RlLCBjb250aW51YXJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWQgbm8gZXhpc3RlIG8geWEgZnVlIGVsaW1pbmFkYScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9idGllbmUgZWwgdGlwbyBkZSBub2RvIHBhcmEgbGFiZWxzXG4gICAgICovXG4gICAgZ2V0Tm9kZVR5cGUobm9kZUNvbmZpZykge1xuICAgICAgICBpZiAobm9kZUNvbmZpZy5pc0Jvb3Rub2RlKVxuICAgICAgICAgICAgcmV0dXJuICdib290bm9kZSc7XG4gICAgICAgIGlmIChub2RlQ29uZmlnLmlzUnBjKVxuICAgICAgICAgICAgcmV0dXJuICdycGMnO1xuICAgICAgICBpZiAobm9kZUNvbmZpZy5pc01pbmVyKVxuICAgICAgICAgICAgcmV0dXJuICdtaW5lcic7XG4gICAgICAgIHJldHVybiAndmFsaWRhdG9yJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXNwZXJhIHVuIHRpZW1wbyBkZXRlcm1pbmFkb1xuICAgICAqL1xuICAgIHNsZWVwKG1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2J0aWVuZSBpbmZvcm1hY2nDs24gZGUgdG9kb3MgbG9zIG5vZG9zIGRlIGxhIHJlZFxuICAgICAqL1xuICAgIGFzeW5jIGdldE5ldHdvcmtTdGF0dXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrSW5mbyA9IGF3YWl0IHRoaXMuZ2V0TmV0d29ya0luZm8odGhpcy5uZXR3b3JrQ29uZmlnLm5ldHdvcmtOYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmV0d29yazoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuZXR3b3JrSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdWJuZXQ6IG5ldHdvcmtJbmZvLmNvbmZpZy5zdWJuZXQsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTm9kZXM6IG5ldHdvcmtJbmZvLmNvbnRhaW5lcnMubGVuZ3RoXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBub2RlczogbmV0d29ya0luZm8uY29udGFpbmVycy5tYXAoY29udGFpbmVyID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGNvbnRhaW5lci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBpcDogY29udGFpbmVyLmlwLFxuICAgICAgICAgICAgICAgICAgICBpZDogY29udGFpbmVyLmlkXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBvYnRlbmllbmRvIGVzdGFkbyBkZSBsYSByZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRpZW5lIGxvcyBsb2dzIGRlIHVuIGNvbnRlbmVkb3IgZXNwZWPDrWZpY28gKMO6dGlsIHBhcmEgZGVidWdnaW5nKVxuICAgICAqL1xuICAgIGFzeW5jIGdldE5vZGVMb2dzKG5vZGVOYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBBY2NlZGVyIGFsIGRvY2tlciBpbnN0YW5jZSBkZWwgcGFkcmVcbiAgICAgICAgICAgIGNvbnN0IGRvY2tlckluc3RhbmNlID0gdGhpcy5kb2NrZXI7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2NrZXJJbnN0YW5jZS5nZXRDb250YWluZXIobm9kZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgbG9ncyA9IGF3YWl0IGNvbnRhaW5lci5sb2dzKHtcbiAgICAgICAgICAgICAgICBzdGRvdXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RkZXJyOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhaWw6IDUwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsb2dzLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIG9idGVuaWVuZG8gbG9ncyBkZSAke25vZGVOYW1lfTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CZXN1RGVwbG95ZXIgPSBCZXN1RGVwbG95ZXI7XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwib3duS2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJhciIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImxlbmd0aCIsIm1vZCIsInJlc3VsdCIsImkiLCJleHBvcnRzIiwiQmVzdURlcGxveWVyIiwiZG9ja2VyX21hbmFnZXJfMSIsInJlcXVpcmUiLCJwYXRoIiwiZnMiLCJjcnlwdG8iLCJEb2NrZXJNYW5hZ2VyIiwiY29uc3RydWN0b3IiLCJuZXR3b3JrQ29uZmlnIiwiZGVwbG95QmVzdU5ldHdvcmsiLCJub2RlcyIsImNsZWFudXBOZXR3b3JrIiwiY2xlYW51cFByZXZpb3VzRGF0YSIsImVuc3VyZURhdGFEaXJlY3RvcnkiLCJjcmVhdGVOb2RlRGlyZWN0b3JpZXMiLCJ1cGRhdGVDb25maWdXaXRoQm9vdG5vZGUiLCJjcmVhdGVCZXN1TmV0d29yayIsIm5vZGUiLCJkZXBsb3lCZXN1Tm9kZSIsInNsZWVwIiwiY29uc29sZSIsImxvZyIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiYWJzb2x1dGVQYXRoIiwicmVzb2x2ZSIsImRhdGFQYXRoIiwiZXhpc3RzU3luYyIsInJlbW92ZURpcmVjdG9yeVJlY3Vyc2l2ZSIsImRpclBhdGgiLCJybVN5bmMiLCJyZWN1cnNpdmUiLCJmb3JjZSIsIm1rZGlyU3luYyIsImNyZWF0ZUNvbmZpZ0ZpbGVzIiwiY29uZmlnQ29udGVudCIsImJvb3Rub2RlQ29uZmlnQ29udGVudCIsImdlbmVzaXNDb250ZW50IiwiY29uZmlnIiwiY2hhaW5JZCIsImxvbmRvbkJsb2NrIiwiY2xpcXVlIiwiYmxvY2twZXJpb2RzZWNvbmRzIiwiZXBvY2hsZW5naHQiLCJjcmVhdGVlbXB0eWJsb2NrcyIsImV4dHJhRGF0YSIsImdhc0xpbWl0IiwiZGlmZmljdWx0eSIsImFsbG9jIiwiY29uZmlnUGF0aCIsImpvaW4iLCJib290bm9kZUNvbmZpZ1BhdGgiLCJnZW5lc2lzUGF0aCIsIndyaXRlRmlsZVN5bmMiLCJKU09OIiwic3RyaW5naWZ5IiwiYmFzZVBhdGgiLCJub2RlUGF0aCIsIm5hbWUiLCJwcml2YXRlS2V5IiwicmFuZG9tQnl0ZXMiLCJwcml2YXRlS2V5SGV4IiwidG9TdHJpbmciLCJhZGRyZXNzQnl0ZXMiLCJhZGRyZXNzIiwiZmxhZyIsImlzQm9vdG5vZGUiLCJwdWJsaWNLZXlCeXRlcyIsInB1YmxpY0tleSIsImVub2RlIiwiaXAiLCJzdWJzdHJpbmciLCJrZXlDb250ZW50IiwicmVhZEZpbGVTeW5jIiwiYm9vdG5vZGUiLCJmaW5kIiwiZW5vZGVQYXRoIiwidHJpbSIsInVwZGF0ZUdlbmVzaXNXaXRoVmFsaWRhdG9ycyIsIm1pbmVyTm9kZXMiLCJmaWx0ZXIiLCJpc01pbmVyIiwiYWRkcmVzc1BhdGgiLCJmaXJzdE1pbmVyQWRkcmVzcyIsImJhbGFuY2UiLCJjcmVhdGVOZXR3b3JrIiwibmV0d29ya05hbWUiLCJzdWJuZXQiLCJsYWJlbHMiLCJub2RlQ29uZmlnIiwiY29udGFpbmVyT3B0aW9ucyIsImJ1aWxkQmVzdUNvbnRhaW5lck9wdGlvbnMiLCJnZXROb2RlVHlwZSIsImNvbnRhaW5lcklkIiwiY3JlYXRlQ29udGFpbmVyIiwiY29udGFpbmVySW5mbyIsImdldENvbnRhaW5lckluZm8iLCJzdGF0ZSIsInZvbHVtZU1vdW50IiwiY21kIiwiYnVpbGRCZXN1Q29tbWFuZCIsInBvcnRCaW5kaW5ncyIsImlzUnBjIiwiSG9zdFBvcnQiLCJJbWFnZSIsIkNtZCIsIkV4cG9zZWRQb3J0cyIsIkhvc3RDb25maWciLCJCaW5kcyIsIlBvcnRCaW5kaW5ncyIsImtleXMiLCJMYWJlbHMiLCJjb25maWdGaWxlIiwicHVzaCIsInJlbW92ZU5ldHdvcmsiLCJtcyIsIlByb21pc2UiLCJzZXRUaW1lb3V0IiwiZ2V0TmV0d29ya1N0YXR1cyIsIm5ldHdvcmtJbmZvIiwiZ2V0TmV0d29ya0luZm8iLCJuZXR3b3JrIiwidG90YWxOb2RlcyIsImNvbnRhaW5lcnMiLCJtYXAiLCJjb250YWluZXIiLCJpZCIsImdldE5vZGVMb2dzIiwibm9kZU5hbWUiLCJkb2NrZXJJbnN0YW5jZSIsImRvY2tlciIsImdldENvbnRhaW5lciIsImxvZ3MiLCJzdGRvdXQiLCJzdGRlcnIiLCJ0YWlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/devisrael-docker-manager/dist/besu-deployer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/devisrael-docker-manager/dist/docker-manager.js":
/*!**********************************************************************!*\
  !*** ./node_modules/devisrael-docker-manager/dist/docker-manager.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DockerManager = void 0;\nconst dockerode_1 = __importDefault(__webpack_require__(/*! dockerode */ \"dockerode\"));\n/**\n * Clase para gestionar contenedores y redes Docker\n */ class DockerManager {\n    /**\n     * Constructor de la clase DockerManager\n     * @param options Opciones de conexión a Docker (opcional)\n     */ constructor(options){\n        this.docker = new dockerode_1.default(options);\n    }\n    /**\n     * Crea una nueva red Docker\n     * @param options Opciones para crear la red\n     * @returns Promise con el ID de la red creada\n     */ async createNetwork(options) {\n        const { name, subnet, labels = {} } = options;\n        const networkOptions = {\n            Name: name,\n            CheckDuplicate: true,\n            Driver: \"bridge\",\n            IPAM: {\n                Driver: \"default\",\n                Config: [\n                    {\n                        Subnet: subnet\n                    }\n                ]\n            },\n            Labels: labels\n        };\n        try {\n            const network = await this.docker.createNetwork(networkOptions);\n            return network.id;\n        } catch (error) {\n            throw new Error(`Error al crear la red: ${error.message}`);\n        }\n    }\n    /**\n     * Crea un nuevo contenedor Docker\n     * @param options Opciones para crear el contenedor\n     * @returns Promise con el ID del contenedor creado\n     */ async createContainer(options) {\n        const { name, ip, networkName, ...containerOptions } = options;\n        try {\n            // Crear el contenedor\n            const container = await this.docker.createContainer({\n                ...containerOptions,\n                name\n            });\n            const containerId = container.id;\n            // Si se especifica una red, conectar el contenedor a ella\n            if (networkName) {\n                const network = this.docker.getNetwork(networkName);\n                const networkConnectOptions = {\n                    Container: containerId\n                };\n                // Si se especifica una IP, configurarla\n                if (ip) {\n                    networkConnectOptions.EndpointConfig = {\n                        IPAddress: ip\n                    };\n                }\n                await network.connect(networkConnectOptions);\n            }\n            // Iniciar el contenedor\n            await container.start();\n            return containerId;\n        } catch (error) {\n            throw new Error(`Error al crear el contenedor: ${error.message}`);\n        }\n    }\n    /**\n     * Elimina un contenedor Docker\n     * @param nameOrId Nombre o ID del contenedor a eliminar\n     * @param force Si es true, fuerza la eliminación incluso si está en ejecución\n     * @returns Promise que se resuelve cuando el contenedor ha sido eliminado\n     */ async removeContainer(nameOrId, force = true) {\n        try {\n            const container = this.docker.getContainer(nameOrId);\n            await container.remove({\n                force\n            });\n        } catch (error) {\n            throw new Error(`Error al eliminar el contenedor: ${error.message}`);\n        }\n    }\n    /**\n     * Elimina todos los contenedores conectados a una red específica\n     * @param networkNameOrId Nombre o ID de la red\n     * @returns Promise que se resuelve cuando todos los contenedores han sido eliminados\n     */ async removeContainersInNetwork(networkNameOrId) {\n        try {\n            // Obtener información de la red\n            const network = this.docker.getNetwork(networkNameOrId);\n            const networkInfo = await network.inspect();\n            // Obtener los contenedores conectados a la red\n            const containerIds = Object.keys(networkInfo.Containers || {});\n            // Eliminar cada contenedor\n            for (const containerId of containerIds){\n                await this.removeContainer(containerId);\n            }\n        } catch (error) {\n            throw new Error(`Error al eliminar los contenedores de la red: ${error.message}`);\n        }\n    }\n    /**\n     * Elimina una red Docker y opcionalmente todos sus contenedores\n     * @param networkNameOrId Nombre o ID de la red a eliminar\n     * @param removeContainers Si es true, elimina todos los contenedores conectados a la red\n     * @returns Promise que se resuelve cuando la red ha sido eliminada\n     */ async removeNetwork(networkNameOrId, removeContainers = true) {\n        try {\n            // Si se solicita, eliminar primero los contenedores\n            if (removeContainers) {\n                await this.removeContainersInNetwork(networkNameOrId);\n            }\n            // Eliminar la red\n            const network = this.docker.getNetwork(networkNameOrId);\n            await network.remove();\n        } catch (error) {\n            throw new Error(`Error al eliminar la red: ${error.message}`);\n        }\n    }\n    /**\n     * Obtiene información detallada de una red Docker\n     * @param networkNameOrId Nombre o ID de la red\n     * @returns Promise con la información de la red\n     */ async getNetworkInfo(networkNameOrId) {\n        try {\n            const network = this.docker.getNetwork(networkNameOrId);\n            const info = await network.inspect();\n            const containers = await Promise.all(Object.entries(info.Containers || {}).map(async ([id, container])=>{\n                const containerInfo = await this.docker.getContainer(id).inspect();\n                return {\n                    id,\n                    name: containerInfo.Name.replace(/^\\//, \"\"),\n                    ip: container.IPv4Address?.split(\"/\")[0]\n                };\n            }));\n            return {\n                id: info.Id,\n                name: info.Name,\n                config: {\n                    subnet: info.IPAM?.Config?.[0]?.Subnet,\n                    gateway: info.IPAM?.Config?.[0]?.Gateway\n                },\n                containers\n            };\n        } catch (error) {\n            throw new Error(`Error al obtener información de la red: ${error.message}`);\n        }\n    }\n    /**\n     * Obtiene información detallada de un contenedor Docker\n     * @param containerNameOrId Nombre o ID del contenedor\n     * @returns Promise con la información del contenedor\n     */ async getContainerInfo(containerNameOrId) {\n        try {\n            const container = this.docker.getContainer(containerNameOrId);\n            const info = await container.inspect();\n            const networks = Object.entries(info.NetworkSettings.Networks || {}).map(([name, network])=>({\n                    name,\n                    ip: network.IPAddress\n                }));\n            return {\n                id: info.Id,\n                name: info.Name.replace(/^\\//, \"\"),\n                state: info.State.Status,\n                networks\n            };\n        } catch (error) {\n            throw new Error(`Error al obtener información del contenedor: ${error.message}`);\n        }\n    }\n}\nexports.DockerManager = DockerManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZGV2aXNyYWVsLWRvY2tlci1tYW5hZ2VyL2Rpc3QvZG9ja2VyLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsTUFBTUcsY0FBY1IsZ0JBQWdCUyxtQkFBT0EsQ0FBQyw0QkFBVztBQUN2RDs7Q0FFQyxHQUNELE1BQU1GO0lBQ0Y7OztLQUdDLEdBQ0RHLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJSixZQUFZSyxPQUFPLENBQUNGO0lBQzFDO0lBQ0E7Ozs7S0FJQyxHQUNELE1BQU1HLGNBQWNILE9BQU8sRUFBRTtRQUN6QixNQUFNLEVBQUVJLElBQUksRUFBRUMsTUFBTSxFQUFFQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUdOO1FBQ3RDLE1BQU1PLGlCQUFpQjtZQUNuQkMsTUFBTUo7WUFDTkssZ0JBQWdCO1lBQ2hCQyxRQUFRO1lBQ1JDLE1BQU07Z0JBQ0ZELFFBQVE7Z0JBQ1JFLFFBQVE7b0JBQ0o7d0JBQ0lDLFFBQVFSO29CQUNaO2lCQUNIO1lBQ0w7WUFDQVMsUUFBUVI7UUFDWjtRQUNBLElBQUk7WUFDQSxNQUFNUyxVQUFVLE1BQU0sSUFBSSxDQUFDZCxNQUFNLENBQUNFLGFBQWEsQ0FBQ0k7WUFDaEQsT0FBT1EsUUFBUUMsRUFBRTtRQUNyQixFQUNBLE9BQU9DLE9BQU87WUFDVixNQUFNLElBQUlDLE1BQU0sQ0FBQyx1QkFBdUIsRUFBRUQsTUFBTUUsT0FBTyxDQUFDLENBQUM7UUFDN0Q7SUFDSjtJQUNBOzs7O0tBSUMsR0FD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Q1h0RCxNQUFNNEMsS0FBS3hDLElBQUksQ0FBQytDLE9BQU8sQ0FBQyxPQUFPO2dCQUMvQlksT0FBT25CLEtBQUtvQixLQUFLLENBQUNDLE1BQU07Z0JBQ3hCTDtZQUNKO1FBQ0osRUFDQSxPQUFPL0MsT0FBTztZQUNWLE1BQU0sSUFBSUMsTUFBTSxDQUFDLDZDQUE2QyxFQUFFRCxNQUFNRSxPQUFPLENBQUMsQ0FBQztRQUNuRjtJQUNKO0FBQ0o7QUFDQXpCLHFCQUFxQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2Jlc3UtbmV0d29yay1hcGkvLi9ub2RlX21vZHVsZXMvZGV2aXNyYWVsLWRvY2tlci1tYW5hZ2VyL2Rpc3QvZG9ja2VyLW1hbmFnZXIuanM/ZTYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRG9ja2VyTWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IGRvY2tlcm9kZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkb2NrZXJvZGVcIikpO1xuLyoqXG4gKiBDbGFzZSBwYXJhIGdlc3Rpb25hciBjb250ZW5lZG9yZXMgeSByZWRlcyBEb2NrZXJcbiAqL1xuY2xhc3MgRG9ja2VyTWFuYWdlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZGUgbGEgY2xhc2UgRG9ja2VyTWFuYWdlclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wY2lvbmVzIGRlIGNvbmV4acOzbiBhIERvY2tlciAob3BjaW9uYWwpXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLmRvY2tlciA9IG5ldyBkb2NrZXJvZGVfMS5kZWZhdWx0KG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhIHVuYSBudWV2YSByZWQgRG9ja2VyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3BjaW9uZXMgcGFyYSBjcmVhciBsYSByZWRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbiBlbCBJRCBkZSBsYSByZWQgY3JlYWRhXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlTmV0d29yayhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgc3VibmV0LCBsYWJlbHMgPSB7fSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgbmV0d29ya09wdGlvbnMgPSB7XG4gICAgICAgICAgICBOYW1lOiBuYW1lLFxuICAgICAgICAgICAgQ2hlY2tEdXBsaWNhdGU6IHRydWUsXG4gICAgICAgICAgICBEcml2ZXI6ICdicmlkZ2UnLFxuICAgICAgICAgICAgSVBBTToge1xuICAgICAgICAgICAgICAgIERyaXZlcjogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgICAgIENvbmZpZzogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTdWJuZXQ6IHN1Ym5ldFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIExhYmVsczogbGFiZWxzXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5kb2NrZXIuY3JlYXRlTmV0d29yayhuZXR3b3JrT3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yay5pZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgYWwgY3JlYXIgbGEgcmVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYSB1biBudWV2byBjb250ZW5lZG9yIERvY2tlclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wY2lvbmVzIHBhcmEgY3JlYXIgZWwgY29udGVuZWRvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29uIGVsIElEIGRlbCBjb250ZW5lZG9yIGNyZWFkb1xuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUNvbnRhaW5lcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgaXAsIG5ldHdvcmtOYW1lLCAuLi5jb250YWluZXJPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ3JlYXIgZWwgY29udGVuZWRvclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gYXdhaXQgdGhpcy5kb2NrZXIuY3JlYXRlQ29udGFpbmVyKHtcbiAgICAgICAgICAgICAgICAuLi5jb250YWluZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVySWQgPSBjb250YWluZXIuaWQ7XG4gICAgICAgICAgICAvLyBTaSBzZSBlc3BlY2lmaWNhIHVuYSByZWQsIGNvbmVjdGFyIGVsIGNvbnRlbmVkb3IgYSBlbGxhXG4gICAgICAgICAgICBpZiAobmV0d29ya05hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5kb2NrZXIuZ2V0TmV0d29yayhuZXR3b3JrTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV0d29ya0Nvbm5lY3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBDb250YWluZXI6IGNvbnRhaW5lcklkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBTaSBzZSBlc3BlY2lmaWNhIHVuYSBJUCwgY29uZmlndXJhcmxhXG4gICAgICAgICAgICAgICAgaWYgKGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtDb25uZWN0T3B0aW9ucy5FbmRwb2ludENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIElQQWRkcmVzczogaXBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV0d29yay5jb25uZWN0KG5ldHdvcmtDb25uZWN0T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbmljaWFyIGVsIGNvbnRlbmVkb3JcbiAgICAgICAgICAgIGF3YWl0IGNvbnRhaW5lci5zdGFydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcklkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBhbCBjcmVhciBlbCBjb250ZW5lZG9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRWxpbWluYSB1biBjb250ZW5lZG9yIERvY2tlclxuICAgICAqIEBwYXJhbSBuYW1lT3JJZCBOb21icmUgbyBJRCBkZWwgY29udGVuZWRvciBhIGVsaW1pbmFyXG4gICAgICogQHBhcmFtIGZvcmNlIFNpIGVzIHRydWUsIGZ1ZXJ6YSBsYSBlbGltaW5hY2nDs24gaW5jbHVzbyBzaSBlc3TDoSBlbiBlamVjdWNpw7NuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBxdWUgc2UgcmVzdWVsdmUgY3VhbmRvIGVsIGNvbnRlbmVkb3IgaGEgc2lkbyBlbGltaW5hZG9cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVDb250YWluZXIobmFtZU9ySWQsIGZvcmNlID0gdHJ1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5kb2NrZXIuZ2V0Q29udGFpbmVyKG5hbWVPcklkKTtcbiAgICAgICAgICAgIGF3YWl0IGNvbnRhaW5lci5yZW1vdmUoeyBmb3JjZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgYWwgZWxpbWluYXIgZWwgY29udGVuZWRvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVsaW1pbmEgdG9kb3MgbG9zIGNvbnRlbmVkb3JlcyBjb25lY3RhZG9zIGEgdW5hIHJlZCBlc3BlY8OtZmljYVxuICAgICAqIEBwYXJhbSBuZXR3b3JrTmFtZU9ySWQgTm9tYnJlIG8gSUQgZGUgbGEgcmVkXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBxdWUgc2UgcmVzdWVsdmUgY3VhbmRvIHRvZG9zIGxvcyBjb250ZW5lZG9yZXMgaGFuIHNpZG8gZWxpbWluYWRvc1xuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUNvbnRhaW5lcnNJbk5ldHdvcmsobmV0d29ya05hbWVPcklkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBPYnRlbmVyIGluZm9ybWFjacOzbiBkZSBsYSByZWRcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLmRvY2tlci5nZXROZXR3b3JrKG5ldHdvcmtOYW1lT3JJZCk7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrSW5mbyA9IGF3YWl0IG5ldHdvcmsuaW5zcGVjdCgpO1xuICAgICAgICAgICAgLy8gT2J0ZW5lciBsb3MgY29udGVuZWRvcmVzIGNvbmVjdGFkb3MgYSBsYSByZWRcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lcklkcyA9IE9iamVjdC5rZXlzKG5ldHdvcmtJbmZvLkNvbnRhaW5lcnMgfHwge30pO1xuICAgICAgICAgICAgLy8gRWxpbWluYXIgY2FkYSBjb250ZW5lZG9yXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRhaW5lcklkIG9mIGNvbnRhaW5lcklkcykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVtb3ZlQ29udGFpbmVyKGNvbnRhaW5lcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgYWwgZWxpbWluYXIgbG9zIGNvbnRlbmVkb3JlcyBkZSBsYSByZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbGltaW5hIHVuYSByZWQgRG9ja2VyIHkgb3BjaW9uYWxtZW50ZSB0b2RvcyBzdXMgY29udGVuZWRvcmVzXG4gICAgICogQHBhcmFtIG5ldHdvcmtOYW1lT3JJZCBOb21icmUgbyBJRCBkZSBsYSByZWQgYSBlbGltaW5hclxuICAgICAqIEBwYXJhbSByZW1vdmVDb250YWluZXJzIFNpIGVzIHRydWUsIGVsaW1pbmEgdG9kb3MgbG9zIGNvbnRlbmVkb3JlcyBjb25lY3RhZG9zIGEgbGEgcmVkXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBxdWUgc2UgcmVzdWVsdmUgY3VhbmRvIGxhIHJlZCBoYSBzaWRvIGVsaW1pbmFkYVxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZU5ldHdvcmsobmV0d29ya05hbWVPcklkLCByZW1vdmVDb250YWluZXJzID0gdHJ1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU2kgc2Ugc29saWNpdGEsIGVsaW1pbmFyIHByaW1lcm8gbG9zIGNvbnRlbmVkb3Jlc1xuICAgICAgICAgICAgaWYgKHJlbW92ZUNvbnRhaW5lcnMpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUNvbnRhaW5lcnNJbk5ldHdvcmsobmV0d29ya05hbWVPcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVsaW1pbmFyIGxhIHJlZFxuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IHRoaXMuZG9ja2VyLmdldE5ldHdvcmsobmV0d29ya05hbWVPcklkKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldHdvcmsucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGFsIGVsaW1pbmFyIGxhIHJlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9idGllbmUgaW5mb3JtYWNpw7NuIGRldGFsbGFkYSBkZSB1bmEgcmVkIERvY2tlclxuICAgICAqIEBwYXJhbSBuZXR3b3JrTmFtZU9ySWQgTm9tYnJlIG8gSUQgZGUgbGEgcmVkXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb24gbGEgaW5mb3JtYWNpw7NuIGRlIGxhIHJlZFxuICAgICAqL1xuICAgIGFzeW5jIGdldE5ldHdvcmtJbmZvKG5ldHdvcmtOYW1lT3JJZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IHRoaXMuZG9ja2VyLmdldE5ldHdvcmsobmV0d29ya05hbWVPcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCBuZXR3b3JrLmluc3BlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhpbmZvLkNvbnRhaW5lcnMgfHwge30pLm1hcChhc3luYyAoW2lkLCBjb250YWluZXJdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVySW5mbyA9IGF3YWl0IHRoaXMuZG9ja2VyLmdldENvbnRhaW5lcihpZCkuaW5zcGVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjb250YWluZXJJbmZvLk5hbWUucmVwbGFjZSgvXlxcLy8sICcnKSxcbiAgICAgICAgICAgICAgICAgICAgaXA6IGNvbnRhaW5lci5JUHY0QWRkcmVzcz8uc3BsaXQoJy8nKVswXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBpbmZvLklkLFxuICAgICAgICAgICAgICAgIG5hbWU6IGluZm8uTmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgc3VibmV0OiBpbmZvLklQQU0/LkNvbmZpZz8uWzBdPy5TdWJuZXQsXG4gICAgICAgICAgICAgICAgICAgIGdhdGV3YXk6IGluZm8uSVBBTT8uQ29uZmlnPy5bMF0/LkdhdGV3YXlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcnNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGFsIG9idGVuZXIgaW5mb3JtYWNpw7NuIGRlIGxhIHJlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9idGllbmUgaW5mb3JtYWNpw7NuIGRldGFsbGFkYSBkZSB1biBjb250ZW5lZG9yIERvY2tlclxuICAgICAqIEBwYXJhbSBjb250YWluZXJOYW1lT3JJZCBOb21icmUgbyBJRCBkZWwgY29udGVuZWRvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29uIGxhIGluZm9ybWFjacOzbiBkZWwgY29udGVuZWRvclxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbnRhaW5lckluZm8oY29udGFpbmVyTmFtZU9ySWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZG9ja2VyLmdldENvbnRhaW5lcihjb250YWluZXJOYW1lT3JJZCk7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQgY29udGFpbmVyLmluc3BlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtzID0gT2JqZWN0LmVudHJpZXMoaW5mby5OZXR3b3JrU2V0dGluZ3MuTmV0d29ya3MgfHwge30pLm1hcCgoW25hbWUsIG5ldHdvcmtdKSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgaXA6IG5ldHdvcmsuSVBBZGRyZXNzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBpbmZvLklkLFxuICAgICAgICAgICAgICAgIG5hbWU6IGluZm8uTmFtZS5yZXBsYWNlKC9eXFwvLywgJycpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBpbmZvLlN0YXRlLlN0YXR1cyxcbiAgICAgICAgICAgICAgICBuZXR3b3Jrc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgYWwgb2J0ZW5lciBpbmZvcm1hY2nDs24gZGVsIGNvbnRlbmVkb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRG9ja2VyTWFuYWdlciA9IERvY2tlck1hbmFnZXI7XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRG9ja2VyTWFuYWdlciIsImRvY2tlcm9kZV8xIiwicmVxdWlyZSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImRvY2tlciIsImRlZmF1bHQiLCJjcmVhdGVOZXR3b3JrIiwibmFtZSIsInN1Ym5ldCIsImxhYmVscyIsIm5ldHdvcmtPcHRpb25zIiwiTmFtZSIsIkNoZWNrRHVwbGljYXRlIiwiRHJpdmVyIiwiSVBBTSIsIkNvbmZpZyIsIlN1Ym5ldCIsIkxhYmVscyIsIm5ldHdvcmsiLCJpZCIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiY3JlYXRlQ29udGFpbmVyIiwiaXAiLCJuZXR3b3JrTmFtZSIsImNvbnRhaW5lck9wdGlvbnMiLCJjb250YWluZXIiLCJjb250YWluZXJJZCIsImdldE5ldHdvcmsiLCJuZXR3b3JrQ29ubmVjdE9wdGlvbnMiLCJDb250YWluZXIiLCJFbmRwb2ludENvbmZpZyIsIklQQWRkcmVzcyIsImNvbm5lY3QiLCJzdGFydCIsInJlbW92ZUNvbnRhaW5lciIsIm5hbWVPcklkIiwiZm9yY2UiLCJnZXRDb250YWluZXIiLCJyZW1vdmUiLCJyZW1vdmVDb250YWluZXJzSW5OZXR3b3JrIiwibmV0d29ya05hbWVPcklkIiwibmV0d29ya0luZm8iLCJpbnNwZWN0IiwiY29udGFpbmVySWRzIiwia2V5cyIsIkNvbnRhaW5lcnMiLCJyZW1vdmVOZXR3b3JrIiwicmVtb3ZlQ29udGFpbmVycyIsImdldE5ldHdvcmtJbmZvIiwiaW5mbyIsImNvbnRhaW5lcnMiLCJQcm9taXNlIiwiYWxsIiwiZW50cmllcyIsIm1hcCIsImNvbnRhaW5lckluZm8iLCJyZXBsYWNlIiwiSVB2NEFkZHJlc3MiLCJzcGxpdCIsIklkIiwiY29uZmlnIiwiZ2F0ZXdheSIsIkdhdGV3YXkiLCJnZXRDb250YWluZXJJbmZvIiwiY29udGFpbmVyTmFtZU9ySWQiLCJuZXR3b3JrcyIsIk5ldHdvcmtTZXR0aW5ncyIsIk5ldHdvcmtzIiwic3RhdGUiLCJTdGF0ZSIsIlN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/devisrael-docker-manager/dist/docker-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/devisrael-docker-manager/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/devisrael-docker-manager/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BesuDeployer = exports.DockerManager = void 0;\nvar docker_manager_1 = __webpack_require__(/*! ./docker-manager */ \"(rsc)/./node_modules/devisrael-docker-manager/dist/docker-manager.js\");\nObject.defineProperty(exports, \"DockerManager\", ({\n    enumerable: true,\n    get: function() {\n        return docker_manager_1.DockerManager;\n    }\n}));\nvar besu_deployer_1 = __webpack_require__(/*! ./besu-deployer */ \"(rsc)/./node_modules/devisrael-docker-manager/dist/besu-deployer.js\");\nObject.defineProperty(exports, \"BesuDeployer\", ({\n    enumerable: true,\n    get: function() {\n        return besu_deployer_1.BesuDeployer;\n    }\n}));\n__exportStar(__webpack_require__(/*! ./types */ \"(rsc)/./node_modules/devisrael-docker-manager/dist/types.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZGV2aXNyYWVsLWRvY2tlci1tYW5hZ2VyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RMLG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQ3BELElBQUlRLG1CQUFtQkMsbUJBQU9BLENBQUMsOEZBQWtCO0FBQ2pEekIsaURBQWdEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9XLGlCQUFpQkQsYUFBYTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2xJLElBQUlHLGtCQUFrQkQsbUJBQU9BLENBQUMsNEZBQWlCO0FBQy9DekIsZ0RBQStDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9hLGdCQUFnQkosWUFBWTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQy9IUCxhQUFhVSxtQkFBT0EsQ0FBQyw0RUFBUyxHQUFHVCIsInNvdXJjZXMiOlsid2VicGFjazovL2Jlc3UtbmV0d29yay1hcGkvLi9ub2RlX21vZHVsZXMvZGV2aXNyYWVsLWRvY2tlci1tYW5hZ2VyL2Rpc3QvaW5kZXguanM/YzRlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZXN1RGVwbG95ZXIgPSBleHBvcnRzLkRvY2tlck1hbmFnZXIgPSB2b2lkIDA7XG52YXIgZG9ja2VyX21hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL2RvY2tlci1tYW5hZ2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9ja2VyTWFuYWdlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9ja2VyX21hbmFnZXJfMS5Eb2NrZXJNYW5hZ2VyOyB9IH0pO1xudmFyIGJlc3VfZGVwbG95ZXJfMSA9IHJlcXVpcmUoXCIuL2Jlc3UtZGVwbG95ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCZXN1RGVwbG95ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJlc3VfZGVwbG95ZXJfMS5CZXN1RGVwbG95ZXI7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJCZXN1RGVwbG95ZXIiLCJEb2NrZXJNYW5hZ2VyIiwiZG9ja2VyX21hbmFnZXJfMSIsInJlcXVpcmUiLCJiZXN1X2RlcGxveWVyXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/devisrael-docker-manager/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/devisrael-docker-manager/dist/types.js":
/*!*************************************************************!*\
  !*** ./node_modules/devisrael-docker-manager/dist/types.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZGV2aXNyYWVsLWRvY2tlci1tYW5hZ2VyL2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iZXN1LW5ldHdvcmstYXBpLy4vbm9kZV9tb2R1bGVzL2RldmlzcmFlbC1kb2NrZXItbWFuYWdlci9kaXN0L3R5cGVzLmpzPzFhNjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/devisrael-docker-manager/dist/types.js\n");

/***/ })

};
;